from __future__ import annotations

import argparse
from pathlib import Path
from typing import List, Optional, Sequence, Tuple, Union

import torch


def _parse_obj_face_token(tok: str, vert_count: int) -> int:
    # Supports: v, v/vt, v//vn, v/vt/vn
    v_str = tok.split("/")[0]
    if not v_str:
        raise ValueError(f"Bad face token: {tok!r}")
    idx = int(v_str)
    if idx < 0:
        idx = vert_count + idx
    else:
        idx = idx - 1
    return idx


def read_obj(
    path: Union[str, Path], device: Optional[torch.device] = None
) -> Tuple[torch.Tensor, List[torch.Tensor]]:
    """
    Minimal OBJ reader: vertices + polygon faces.

    - Reads `v` and `f` records.
    - Ignores normals/uvs/materials.
    - Faces returned as a list of 1D LongTensors (variable length).
    """
    path = Path(path)
    verts: List[List[float]] = []
    faces: List[torch.Tensor] = []

    with path.open("r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if line.startswith("v "):
                parts = line.split()
                if len(parts) < 4:
                    continue
                verts.append([float(parts[1]), float(parts[2]), float(parts[3])])
            elif line.startswith("f "):
                parts = line.split()[1:]
                if len(parts) < 3:
                    continue
                idxs = [_parse_obj_face_token(tok, len(verts)) for tok in parts]
                faces.append(torch.tensor(idxs, dtype=torch.long))

    v = torch.tensor(verts, dtype=torch.float32)
    if device is None:
        device = v.device
    v = v.to(device)
    faces = [f.to(device) for f in faces]
    return v, faces


def triangulate_faces(faces: Sequence[torch.Tensor]) -> List[torch.Tensor]:
    """Fan triangulation: (v0, vi, v{i+1}) for i=1..n-2."""
    tris: List[torch.Tensor] = []
    for face in faces:
        if face.numel() < 3:
            continue
        if face.numel() == 3:
            tris.append(face)
            continue
        v0 = face[0]
        for i in range(1, face.numel() - 1):
            tris.append(torch.stack([v0, face[i], face[i + 1]]))
    return tris


def write_obj(
    path: Union[str, Path],
    verts: torch.Tensor,
    faces: Sequence[torch.Tensor],
    *,
    triangulate: bool = False,
) -> None:
    """
    Write an OBJ with `v` + `f`.

    Set `triangulate=True` if your downstream tool dislikes n-gons/quads.
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    v = verts.detach().cpu()
    f_list = list(faces)
    if triangulate:
        f_list = triangulate_faces(f_list)

    with path.open("w", encoding="utf-8") as f:
        f.write("# generated by cc_subdivide.py\n")
        for xyz in v:
            f.write(f"v {xyz[0].item()} {xyz[1].item()} {xyz[2].item()}\n")
        for face in f_list:
            idxs = (face.detach().cpu().to(torch.long) + 1).tolist()
            f.write("f " + " ".join(str(i) for i in idxs) + "\n")


def faces_tensor_to_list(faces: torch.Tensor) -> List[torch.Tensor]:
    """Convert a dense (F, N) faces tensor to a list; trims -1 padding if present."""
    out: List[torch.Tensor] = []
    for row in faces:
        if (row < 0).any():
            row = row[row >= 0]
        if row.numel() >= 3:
            out.append(row.to(dtype=torch.long))
    return out


def catmull_clark_subdivide(
    verts: torch.Tensor,
    faces: Union[Sequence[torch.Tensor], torch.Tensor],
    *,
    return_debug: bool = False,
):
    """
    One Catmull-Clark subdivision step.

    Input: general polygon mesh (tri/quads/n-gons).
    Output: quad mesh (each m-gon becomes m quads).

    Differentiable w.r.t. `verts`.
    """
    if verts.ndim != 2 or verts.shape[1] != 3:
        raise ValueError(f"Expected verts shape (V, 3), got {tuple(verts.shape)}")

    device = verts.device
    dtype = verts.dtype

    if isinstance(faces, torch.Tensor):
        faces_list = faces_tensor_to_list(faces.to(device=device))
    else:
        faces_list = [f.to(device=device, dtype=torch.long) for f in faces]

    faces_list = [f for f in faces_list if f.numel() >= 3]
    f_count = len(faces_list)
    if f_count == 0:
        raise ValueError("No valid faces")

    face_sizes = torch.tensor(
        [int(f.numel()) for f in faces_list], device=device, dtype=torch.long
    )
    corner_verts = torch.cat(faces_list, dim=0)  # (C,)
    corner_faces = torch.repeat_interleave(
        torch.arange(f_count, device=device, dtype=torch.long), face_sizes
    )

    # Face points.
    face_sum = torch.zeros((f_count, 3), device=device, dtype=dtype)
    face_sum.index_add_(0, corner_faces, verts[corner_verts])
    face_points = face_sum / face_sizes.to(dtype=dtype).unsqueeze(1)

    # Directed edges (C, 2) aligned with corner order.
    edge_verts = torch.cat(
        [torch.stack([f, f.roll(-1)], dim=1) for f in faces_list], dim=0
    )
    edge_faces = corner_faces

    # Unique undirected edges.
    edge_verts_sorted, _ = edge_verts.sort(dim=1)
    unique_edges, inverse = torch.unique(edge_verts_sorted, dim=0, return_inverse=True)
    e_count = int(unique_edges.shape[0])

    # Edge points.
    edge_mid = verts[unique_edges].mean(dim=1)  # (E, 3)

    edge_face_sum = torch.zeros((e_count, 3), device=device, dtype=dtype)
    edge_face_sum.index_add_(0, inverse, face_points[edge_faces])

    edge_face_count = torch.zeros((e_count,), device=device, dtype=torch.long)
    edge_face_count.index_add_(
        0, inverse, torch.ones((inverse.shape[0],), device=device, dtype=torch.long)
    )

    edge_face_mean = edge_face_sum / edge_face_count.clamp(min=1).to(dtype=dtype).unsqueeze(
        1
    )
    is_boundary_edge = edge_face_count == 1
    edge_points = torch.where(
        is_boundary_edge.unsqueeze(1), edge_mid, 0.5 * (edge_mid + edge_face_mean)
    )

    # Vertex points (interior rule).
    v_count = int(verts.shape[0])

    v_face_sum = torch.zeros((v_count, 3), device=device, dtype=dtype)
    v_face_sum.index_add_(0, corner_verts, face_points[corner_faces])

    v_face_count = torch.zeros((v_count,), device=device, dtype=torch.long)
    v_face_count.index_add_(
        0,
        corner_verts,
        torch.ones((corner_verts.shape[0],), device=device, dtype=torch.long),
    )

    F = v_face_sum / v_face_count.clamp(min=1).to(dtype=dtype).unsqueeze(1)

    v_edge_sum = torch.zeros((v_count, 3), device=device, dtype=dtype)
    v_edge_sum.index_add_(0, unique_edges[:, 0], edge_mid)
    v_edge_sum.index_add_(0, unique_edges[:, 1], edge_mid)

    v_edge_count = torch.zeros((v_count,), device=device, dtype=torch.long)
    ones_e = torch.ones((e_count,), device=device, dtype=torch.long)
    v_edge_count.index_add_(0, unique_edges[:, 0], ones_e)
    v_edge_count.index_add_(0, unique_edges[:, 1], ones_e)

    R = v_edge_sum / v_edge_count.clamp(min=1).to(dtype=dtype).unsqueeze(1)

    n = v_face_count.to(dtype=dtype).clamp(min=1).unsqueeze(1)
    verts_new = (F + 2.0 * R + (n - 3.0) * verts) / n

    # Boundary vertex rule (simple, manifold-ish assumption: 2 boundary neighbors per boundary vertex).
    if bool(is_boundary_edge.any()):
        boundary_edges = unique_edges[is_boundary_edge]
        boundary_verts = torch.unique(boundary_edges)
        verts_new = verts_new.clone()

        for v_idx in boundary_verts.tolist():
            mask0 = boundary_edges[:, 0] == v_idx
            mask1 = boundary_edges[:, 1] == v_idx
            neigh = torch.cat([boundary_edges[mask0, 1], boundary_edges[mask1, 0]], dim=0).unique()
            if neigh.numel() >= 2:
                v_prev = int(neigh[0].item())
                v_next = int(neigh[1].item())
                verts_new[v_idx] = (6.0 * verts[v_idx] + verts[v_prev] + verts[v_next]) / 8.0

    # New faces: each m-gon -> m quads.
    fp_base = v_count
    ep_base = v_count + f_count

    starts = torch.cat(
        [torch.zeros((1,), device=device, dtype=torch.long), face_sizes.cumsum(0)[:-1]]
    )

    quads: List[torch.Tensor] = []
    for face_idx, face in enumerate(faces_list):
        m = int(face.numel())
        start = int(starts[face_idx].item())
        edge_ids = inverse[start : start + m]

        fp = torch.full((m,), fp_base + face_idx, device=device, dtype=torch.long)
        ep_next = ep_base + edge_ids
        ep_prev = ep_next.roll(1)

        quads.append(torch.stack([face, ep_next, fp, ep_prev], dim=1))

    new_faces_quads = torch.cat(quads, dim=0)
    new_verts = torch.cat([verts_new, face_points, edge_points], dim=0)

    if not return_debug:
        return new_verts, new_faces_quads

    debug = {
        "face_points": face_points,
        "unique_edges": unique_edges,
        "edge_points": edge_points,
        "verts_new": verts_new,
        "edge_face_count": edge_face_count,
    }
    return new_verts, new_faces_quads, debug


def subdivide_n(
    verts: torch.Tensor, faces: Union[Sequence[torch.Tensor], torch.Tensor], levels: int
) -> Tuple[torch.Tensor, torch.Tensor]:
    v, f = verts, faces
    for _ in range(int(levels)):
        v, f = catmull_clark_subdivide(v, f)
    return v, f


def faces_quads_to_list(faces_quads: torch.Tensor) -> List[torch.Tensor]:
    return [row.to(dtype=torch.long) for row in faces_quads]


def _main(argv: Optional[Sequence[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="Torch-only Catmull-Clark subdivision (OBJ in/out).")
    parser.add_argument("--in", dest="in_path", required=True, help="Input OBJ path.")
    parser.add_argument("--out", dest="out_path", required=True, help="Output OBJ path.")
    parser.add_argument("--levels", type=int, default=1, help="Subdivision levels.")
    parser.add_argument(
        "--triangulate",
        action="store_true",
        help="Triangulate output faces (fan triangulation).",
    )
    parser.add_argument(
        "--device",
        choices=["cpu", "cuda"],
        default="cuda" if torch.cuda.is_available() else "cpu",
        help="Torch device.",
    )
    args = parser.parse_args(argv)

    device = torch.device(args.device)
    verts, faces = read_obj(args.in_path, device=device)
    v_out, f_out = subdivide_n(verts, faces, args.levels)
    write_obj(args.out_path, v_out, faces_quads_to_list(f_out), triangulate=args.triangulate)
    return 0


if __name__ == "__main__":
    raise SystemExit(_main())

